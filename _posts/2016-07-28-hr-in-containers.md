---
description: HR in Containers
dateModified: '2016-07-28T21:41:17.035Z'
datePublished: '2016-07-28T21:41:35.189Z'
title: ''
author: []
publisher: {}
via: {}
starred: false
sourcePath: _posts/2016-07-28-hr-in-containers.md
inFeed: true
hasPage: false
inNav: false
_type: MediaObject

---
HR in Containers

Software-as-a-Service has been available in Human Resources for just over a decade now. In those ten years, software architecture and delivery has been radically altered, evolving more rapidly than in the previous 60 plus years of computing. The principles of Cloud Computing, especially in providing low-maintenance, scalable access to pools of computing resources, drove not only the hardware & network resources (Infrastructure-as-a-Service) from which "Cloud" originally sprung, but also SaaS architecture & delivery. From the HRIS perspective, we see SaaS as the predominant licensing & delivery model for our applications, whether they be silos like Recruiting, Learning Management, Succession Planning, etc., or full Enterprise HR systems.   
IaaS and SaaS share many common characteristics despite the fact that each delivers and manages very different resources. In particular, the delivery of capabilities in both is performed through selection of configuration options, and not through traditional software coding & assembly processes. With IaaS, the type of computing resource (Windows Server vs. Linux), amount of memory and disk space allocated, type of network (public or private) are all selected as configuration options at launch. Similarly, in SaaS applications, features are all configured, from org structures for workflow & approvals to the plethora payroll options that may be required. In neither case though, is any custom programming performed.   
Between providing all those computing resources, and delivering all those applications services, lies a less familiar Cloud Computing category: Platform-as-a-Service. The PaaS delivery model provides a platform containing the development tools and runtimes that allow application development activities to be performed. PaaS normally includes management of the underlying IaaS components as well, making it a bridge between the computing infrastructure and the delivered SaaS application.   
PaaS isn't clearly visible in the HRIS domain, but does have both tangential as well as embedded presence. General Purpose application vendors such as those delivering analytics or data integration often provide a PaaS environment that allows stakeholders to develop functionality beyond that provided by their "as-a-Service" configuration capabilities. In these cases, custom development normally takes on the acquisition of data from an HRIS, and potential extensions of functionality within their environment where standard configuration isn't sufficient to meet business needs. Regardless, in this PaaS use case, any extensions are performed with the development tools provided or allowed on the vendor's platform, and tends to be tangential to core HRIS delivery.   
PaaS embedded in an HRIS application isn't well-known to application consumers either; these environments are available only to vendor implementers or developers.   
Client facing resources within the vendors' staff typically have access to configuration & management tools whose capabilities exceed those of client administrators. Some of these are not strictly PaaS, but offer global configuration capabilities across a multi-tenant environment. This is often used to create custom data elements, or screen layouts for clients. Other vendor-accessible tools do provide specific high-level development access for implementation specialists, including custom screen layouts with HTML/CSS or advanced validation of data entry with Javascript.   
A more complete version of internal PaaS is also prevalent. A vendor's internal development teams have the capacity to deploy complete images of servers that contain both production-ready artifacts as well as the development access to significantly modify that image. Each developer, or each small team of developers, can then launch images, design and program to enhance or correct features in the core system without impacting any other ongoing activities, whether those be parallel development efforts, downstream acceptance testing, or (certainly) promotion of new features to general availability. They can repeatedly create, develop, and destroy these instances as they rapidly deliver feature enhancements, all without the delays inherent in pre-as-a-Service environments.   
Business needs, especially those regarding speed of delivery, and the increasing need for security, continue to drive evolution in development practices and the fundamental frameworks of Cloud Computing. Much as PaaS currently bridges & blurs IaaS into SaaS, the current pace of evolution is further binding the two together. Despite the modernity of SaaS, most of our HRIS architectures have roots in monolithic software architectures. With these all-encompassing frameworks, all features are coupled tightly, and need to be upgraded all at once and with careful impact analysis. Release Management, determining which features can be included in a next version, becomes a full-time endeavor, especially in ensuring that dependencies between both new and existing components aren't overlooked. Monolithic architectures also place additional security burdens on the entire application: data and processes with the least need for security must be as secure as those with the greatest need for security, only because they're all lumped together. For example, though a company's list of locations doesn't have the same level of security & privacy requirements as does an employee's information, a monolithic architecture forces the same security constraints on both. Security mechanisms become increasingly complex with each set of information (and sets of access roles) that are added to the application.   
Breaking up the monolithic application into smaller & smaller parts (increasing the granularity) allows for more ability to change the smaller parts without affecting the entirety of the application. In doing so, segregation of highly-sensitive data from less-sensitive allows finer-grained control of security and privacy as well.   
Segmenting functionality into logical silo allows segmentation of sensitive signup & updating of personal information, and view-only access to login, view one's own data & access reports. There are certainly different security requirements for each of these sets of functionality, allowing the services that perform that functionality to define & enforce their own security compliance constraints. In addition though, the increased granularity allows separate teams to work independently on functionality with little impact on other teams' efforts. (Coordination between teams is still and always required, but segmentation allows them to work on independent features and minimize impacts on one another.)   
The Cloud Computing response to this evolution has been the Microservices architecture. The overarching statement is that "Microservices running in Containers enable Serverless deployment." A Microservice would be the functionality entailed in the activity "Update Location" while a corresponding Container would provide the runtime capabilities to execute that Microservice. The Container would launch and run only for the time required to complete the "Update Location" process. In contrast, traditional processing architectures have all services continually running to meet business requirements. Microservices segmentation with containers reduces the computing resources required for an application to run, but also reduces the application's overall "surface" exposed to security attacks.   
Considering that the container is launched for only a brief period of time, it must communicate with the overall environment in a very well-defined and predictable manner. "Update Location" needs to know what other service is performing the request (so that it can authenticate and respond appropriately as the task is completed), and the details of the request itself (e.g., changing the street address for a particular location). This well-defined "contract" for the container's interaction in the environment leads to another benefit to Microservices architectures: so long as the container always acts the same way when launched, it doesn't matter who maintains the internal functionality of the container, nor does it matter what programming method might be used inside the container.   
The promise is this---while continuing to enjoy the benefits of SaaS (vendor-managed infrastructure, security, features) organizations will be able to utilize configuration capabilities and extend the SaaS application to meet custom requirements. The majority of organizations are well-suited to the extensive configuration capabilities in SaaS applications, but we find a large number of enterprises, both large and small, who have custom business requirements, often industry-specific, that require customization outside of offered configuration.   
There are certainly significant considerations to undertake as this threshold is crossed; at the very least, we must learn lessons from the past on-premise customization experiences and put better controls & processes in place. Industry examples are already appearing to pave the way for that future experience.   
  
The ADP Marketplace, while not an application environment itself, is defining patterns of community development that can be referenced as models in other venues. In particular, ADP have defined processes to accept, audit, and certify submissions to their Marketplace (an App Store for HR/Payroll.) Once reviewed, and certified, a submission to the Marketplace becomes available to all other subscribers, with the confidence that the submission will function properly with the targeted ADP application, and with other Marketplace applications & API's.   
In similar fashion, client modifications in a container's Microservice would require some approval process before being injected into a larger scale ecology of services, even on a tenant-specific basis. Those submissions though, could themselves have a range of availability, from private, for the individual company in their tenant space, to individually authorized availability for other companies, or completely open to all other companies on the platform.   
Several early-stage vendors are currently constructing the underlying architecture to deliver Microservices-based PaaS to HR. We'll see some early-adopter beta releases before the end of 2016\. These vendors have selected and implemented the majority of their own technology stacks; in doing so are answering significant questions about future-proofing HR solutions in an environment where options continually shift and evolve.   
  
As illustrated, every facet of the development & deployment for Microservices is represented by a number of choices, and the few exemplified are just samples extracted from longer lists for each facet. The top horizontal list comprise the components that allow Microservices to "live." A specific container definition, configuration of the containers, discovery of all containers (& their properties), routing   
processes between multiple containers, and monitoring the health of containers, are all essential for the operations of Microservices. There are several available Container options, for instance, with Docker being one of the most prominent.   
Operationally, there's also a vertical stack of services & considerations. These describe where the application will actually run, on what database, which platform to run the containers, etc. Once HR applications are available, we in the HRIS industry will be most interested in the Development and Policy areas of the operational stack. Whether we're changing functionality within a Microservice via provided configuration capabilities, or completely customizing them with our own development tools, we'll be using the provided PaaS facilities in order to meet our unique business requirements, and the Policy tools to secure granular access to the business functionality.   
The expectation with a Microservices PaaS is that we'll be able to increase the rate of change as needed to meet existing and emerging business needs, while simultaneously reducing the cost, size, and risk of these changes.   
Microservices won't be limited to new HRIS offerings either; other industries and enterprises have paved the way for migration of large scale application migration to Microservices architectures. In the process, companies like Netflix have created tools enabling Microservice delivery and released those tools to the open source community . The patterns and processes for migration are becoming well-established, separating the monolithic architecture first into large grains, then increasing the granularity step-by-step in subsequent iterations until a "pure Microservices" environment has been completed. We've both worked with several vendors as they begin this process, as well as have seen signs that others are retooling their applications with an eye toward Microservices-based PaaS.   
HR Platform-as-a-Service, especially powered by Microservices, may seem a theoretical (and fairly technical!) dream at the moment, but we can anticipate product announcements and releases coming in the near term. We'll once again see previous architectures beginning to recede in the rear view.